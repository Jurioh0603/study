# 개요
이전에 만들었던 할인 정책을 확장해보자<br>

주문시 `VIP` 회원 `1,000`원 할인 -> `VIP` 회원 `10%` 할인으로 변경할 예정이다.<br>

# 개발
## RateDiscountPolicy 
퍼센트 할인율을 제공하는 로직을 추가로 작성한다.<br>
```
if (member.getGrade() == Grade.VIP) {
  return price * discountPercent / 100;
} else {
  return 0;
}
```

이를 테스트 해본다. 테스트 방법은 생략

## 할인 정책을 애플리케이션에 적용
할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 수정해야한다.<br>
```
// private final DisocountPolicy discountPolicy = new FixDiscountPolicy();
private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
```

### 🤔 문제
역할과 구현의 분리, 다형성과 인터페이스 활용은 잘 되었지만<br>
**`OCP`, `DIP` 객체 지향 설계 원칙을 준수하지 못했다.**

<br>
왜냐하면 `OrderServiceImpl` 가 추상(인터페이스)`DisocountPolicy` 와 구체(구현) 클래스인 `RateDiscountPolicy` 모두 의존하고 있기 때문이다.<br>
또한 `DIP`가 지켜지지 않으니 클라이언트 코드를 수정할 수 밖에 없어 `OCP`를 위반한 것이 되기 때문이다.<br>

### 🌟 해결방법
이를 해결하기 위해 추상클래스에만 의존하도록 변경해야 한다.<br>

## 추상클래스만 의존하도록 변경

`private DiscountPolicy discountPolicy = new RateDiscountPolicy();` -> <br>
`private DiscountPolicy discountPolicy;`<br>

그런데 이를 실행하면 `null pointer exception`이 발생한다.<br>

이를 해결하기 위해 누군가가 클라이언트인 `OrderServiceImpl`에 `DiscountPolicy`의 구현 객체를 대신 생성하고 주입해주어야한다.<br>

# 관심사의 분리
애플리케이션을 공연이라 생각했을 때 현재는 남자 배우가 공연을 준비하고 여자배우까지 섭외해야하는 상황이다. 이를 분리해야한다.<br>
이에 공연 기획자를 추가하여 여배우를 섭외하는 역할을 담당해 관심사를 분리할 수 있다.<br>

즉 우리 코드에도 기획자의 역할을 담당하는 클래스가 있어야한다.<br>

## AppConfig

여기서는  `AppConfig` 클래스가 기획자의 역할을 담당할 것이다.<br>
해당 클래스는 구현 객체를 생성하고 연결하는 책임을 담당할 것이다.<br>

AppConfig
```
public MemberService memberService() {
  return new MemberServiceImpl(new MemoryMemberRepository());
}
public OrderService orderService() {
  return new OrderServiceImpl(
    new MemoryMemberRepository(),
    new FixDiscountPolicy());
}

```

AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.<br>
생성한 객체 인스턴스의 참조를 생성자를 통해 주입해준다.<br>

## 생성자 주입
MemberServiceImpl
```
private final MemberRepository memberRepository;
// 생성자 주입
public MemberServiceImpl(MemberRepository memberRepository) {
  this.memberRepository = memberRepository;
}
public void join(Member member) {
  memberRepository.save(member);
}
public Member findMember(Long memberId) {
  return memberRepository.findById(memberId);
}
```

설계를 변경한 뒤 `MemberServiceImpl`는 단지 `MemberRepository` 인터페이스만 의존한다.<br>
`MemberRepository`의 입장에서 어떤 객체를 주입할지는 외부(`AppConfig`)에서 결정된다.<br>
의존 관계에 대한 고민은 안해도 되고 실행만 집중하면 된다.<br>

이를 통해 DIP가 완성되었다.(구체 Repository클래스를 몰라도 된다. 추상 Repository만 알면 된다.)<br>
관심사도 분리되었다.<br>

## 이제 MemberServiceImpl을 수정해보자
```
private final MemberRepository memberRepository;
private final DiscountPolicy discountPolicy;
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
  this.memberRepository = memberRepository;
  this.discountPolicy = discountPolicy;
}
```
다음과 같이 의존관계 주입만 하면 된다.<br>

# 실행
AppConfig를 실행해보자<br>

## 회원 등록
MemberApp(어플리케이션 실행 클래스)
```
AppConfig appConfig = new AppConfig();
MemberService memberService = appConfig.memberService();
Member member = new Member(1L, "memberA", Grade.VIP);
memberService.join(member);
Member findMember = memberService.findMember(1L);
System.out.println("new member = " + member.getName());
System.out.println("find Member = " + findMember.getName())
```

## 주문
OrderApp
```
AppConfig appConfig = new AppConfig();
MemberService memberService = appConfig.memberService();
OrderService orderService = appConfig.orderService();
long memberId = 1L;
Member member = new Member(memberId, "memberA", Grade.VIP);
memberService.join(member);
Order order = orderService.createOrder(memberId, "itemA", 10000);
System.out.println("order = " + order);
```
위와 같이 AppConfig를 통해 주입한다.<br>

## 테스트
```
@BeforeEach
public void beforeEach() {
  AppConfig appConfig = new AppConfig();
  memberService = appConfig.memberService();
}
```
BeforeEach를 통해 테스트 실행 전 호출한다.<br>

# AppConfig 리팩토링
현재는 AppConfig에 중복이 있고 역할에 따른 구현이 잘 안보인다.<br>
중복되는 코드를 제거하고 리팩토링 한 결과는 아래와 같다.<br>
```
public MemberService memberService() {
  return new MemberServiceImpl(memberRepository());
}
public OrderService orderService() {
  return new OrderServiceImpl(
    memberRepository(),
    discountPolicy());
}
public MemberRepository memberRepository() {
  return new MemoryMemberRepository();
}
public DiscountPolicy discountPolicy() {
  return new FixDiscountPolicy();
}
```

# 😊 이제 할인 정책을 정말로 변경해보자
AppConfig
```
public MemberService memberService() {
  return new MemberServiceImpl(memberRepository());
}
public OrderService orderService() {
  return new OrderServiceImpl(
    memberRepository(),
    discountPolicy());
}
public MemberRepository memberRepository() {
  return new MemoryMemberRepository();
}
public DiscountPolicy discountPolicy() {
  // return new FixDiscountPolicy();
  return new RateDiscountPolicy();
}
```
이제 변경하고 싶을 때 AppConfig만 변경하면 된다. (클라이언트 코드를 변경하지 않아도 된다.)<br>
즉 OCP를 준수하게 되었다.<br>

# 🔥 정리
#### 상황
DIP, OCP가 지켜지지 않은 코드를 리팩토링하였다.<br>

#### 해결방법
기획자의 역할을 하는 AppConfig 클래스를 생성해 역할을 나누었다.<br>
이때 역할은 구현 객체를 생성하고 연결하는 것이다.<br>

#### 결과
DIP 준수 : 역할 분배를 통해 ServiceImpl은 추상(인터페이스)만 의존하면 된다.<br>
OCP 준수 : 변경사항이 있을 때 AppConfig의 코드만 수정하면 되므로 클라이언트 코드를 수정하지 않아도 된다.<br>

# ✍🏻 객체 지향 설계의 5 원칙 적용점을 살펴보자
1. SRP 단일 책임 원칙<br>
클라이언트 객체는 실행하는 역할, AppConfig는 구현 객체를 생성하고 연결하는 역할로 단일 책임을 잘 준수했다.<br>

2. DIP 의존관계 역전의 원칙<br>
> 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.<br>

구현클래스에 대한 의존을 제거함으로 추상 클래스에만 의존하게 되었다.<br>

3. OCP 확장에는 열려있고 변경에는 닫혀있어야한다.<br>
DIP가 지켜지면서 클라이언트 코드를 수정하지 않아도(AppConfig 만 수정하면 됨) 기능 확장이 가능하게 되었다.<br>


# Ioc, DI, 컨테이너
1. Ioc 제어의 역전 (Inversion of Control)<br>
AppConfig 클래스를 통해 객체를 생성하고 주입함에 따라서 ServiceImpl이 아닌 AppConfig가 제어의 흐름을 관리하게 되었다.<br>
이와 같이 제어의 흐름을 외부에서 관리하는 것을 제어의 역전이라고 한다.<br>

> 프레임워크 VS 라이브러리<br>
> 내가 작성한 코드를 제어하고 대신 실행하는 것 = 프레임워크<br>
> 내가 작성한 코드가 직접 제어의 흐름을 담당한다 = 라이브러리<br>

2. DI 의존관계 주입 (Dependency Injection)<br>
ServiceImpl은 인터페이스에 의존한다. 따라서 어떤 구현 객체가 사용될지 모른다.<br>

> 의존관계는 정적인 클래스 의존 관계와 실행시점에 결정되는 동적인 객체 의존관계를 분리해서 생각해야한다.<br>

> 정적인 클래스 의존관계는 코드만 봐도 보이는 의존 관계이다. 예를 들면 ServiceImpl에 MemberRepository(인터페이스)를 의존하고 있는데 이는 볼 수있으므로 정적인 클래스 의존관계이다.<br>

> 그러나 어떤 구현 객체가 주입될지는 알 수없다. 이는 실행시점에서 결정된다. 이를 동적인 객체 의존관계라고 한다.<br>

> 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.<br>

3. 컨테이너<br>
AppConfig처럼 객체를 생성하고 관리하며 의존관계를 연결해주는 것을 Ioc 컨테이너 또는 DI 컨테이너라고 한다.<br>
어셈블러(조합하는 것), 오브젝트 팩토리 등으로 불리기도한다.<br>


# 💪🏻 지금까지 코드를 스프링으로 전환
AppConfig 에 @Configuration 을 붙여주고 각 메서드마다 @Bean을 붙여준다.<br>

## MemberApp에 스프링 컨테이너 적용
```
public static void main(String[] args) {
  // AppConfig appConfig = new AppConfig();
  // MemberService memberService = appConfig.memberService();
  ApplicationContext applicationContext = new
  AnnotationConfigApplicationContext(AppConfig.class);
  MemberService memberService =
  applicationContext.getBean("memberService", MemberService.class);
  Member member = new Member(1L, "memberA", Grade.VIP);
  memberService.join(member);
  Member findMember = memberService.findMember(1L);
  System.out.println("new member = " + member.getName());
  System.out.println("find Member = " + findMember.getName());
}
```
기존 코드에서 AppConfig를 호출하는 부분을 주석처리하고<br>
ApplicationContext의 AnnotationConfigApplicationContext를 통해 Config 클래스를 지정한다.<br>
이후 applicationContext.getBean을 통해 인스턴스를 주입한다. (@Bean이 붙은 메서드명, 주입하고자하는 클래스이름)<br>

# 🌈 느낀점
스프링을 활용하면 어노테이션을 통해 접근할 수 있어 편리할 줄 알았는데 코드가 더 복잡해진것 같다. 이를 더 간단하게 하는 방법은 다음에 배우겠지? 😆
